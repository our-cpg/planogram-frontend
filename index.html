<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Store Planogram Profit Tracker - v3 Complete</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    const { createRoot } = ReactDOM;

// Custom Icons
const Icons = {
  Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>,
  Trash2: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>,
  Save: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>,
  Upload: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>,
  Download: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>,
  Package: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>,
  BarChart3: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 3v18h18"></path><path d="M18 17V9"></path><path d="M13 17V5"></path><path d="M8 17v-3"></path></svg>,
  DollarSign: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>,
  Maximize2: () => <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>,
  Grid3x3: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>,
  Box: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path></svg>,
  Layers: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg>,
  AlignVertical: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="5" y="16" width="14" height="6" rx="2"></rect><rect x="7" y="2" width="10" height="6" rx="2"></rect><path d="M2 12h20"></path></svg>,
  Camera: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>,
  Eye: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>,
  Flame: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"></path></svg>,
  RefreshCw: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>,
  X: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
  Move: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line></svg>
};

const FIXTURE_TYPES = {
  GRID_WALL: {
    id: 'grid_wall',
    name: 'Grid Wall',
    icon: 'Grid3x3',
    color: '#64748b',
    defaultWidth: 120,
    defaultHeight: 200
  },
  JEWELRY_CASE: {
    id: 'jewelry_case',
    name: 'Jewelry Case',
    icon: 'Box',
    color: '#8b5cf6',
    defaultWidth: 100,
    defaultHeight: 80
  },
  GONDOLA: {
    id: 'gondola',
    name: 'Gondola',
    icon: 'Layers',
    color: '#ef4444',
    defaultWidth: 180,
    defaultHeight: 120
  },
  SLAT_WALL: {
    id: 'slat_wall',
    name: 'Slat Wall',
    icon: 'AlignVertical',
    color: '#f59e0b',
    defaultWidth: 150,
    defaultHeight: 180
  },
  END_CAP: {
    id: 'end_cap',
    name: 'End Cap',
    icon: 'Package',
    color: '#10b981',
    defaultWidth: 80,
    defaultHeight: 120
  },
  JEWELRY_DISPLAY: {
    id: 'jewelry_display',
    name: 'Jewelry Display',
    icon: 'Box',
    color: '#fbbf24',
    defaultWidth: 90,
    defaultHeight: 90
  },
  MAKEUP_WALL: {
    id: 'makeup_wall',
    name: 'Makeup Wall',
    icon: 'Grid3x3',
    color: '#ff1493',
    defaultWidth: 200,
    defaultHeight: 220
  }
};

const getCursor = (position) => {
  const cursors = {
    'nw': 'nwse-resize', 'ne': 'nesw-resize', 'se': 'nwse-resize', 'sw': 'nesw-resize',
    'n': 'ns-resize', 's': 'ns-resize', 'e': 'ew-resize', 'w': 'ew-resize'
  };
  return cursors[position];
};

const getHandlePosition = (position) => {
  const positions = {
    'nw': { top: -6, left: -6, width: '12px', height: '12px' },
    'n': { top: -6, left: '50%', transform: 'translateX(-50%)', width: '60px', height: '12px' },
    'ne': { top: -6, right: -6, width: '12px', height: '12px' },
    'e': { right: -6, top: '50%', transform: 'translateY(-50%)', width: '12px', height: '60px' },
    'se': { bottom: -6, right: -6, width: '12px', height: '12px' },
    's': { bottom: -6, left: '50%', transform: 'translateX(-50%)', width: '60px', height: '12px' },
    'sw': { bottom: -6, left: -6, width: '12px', height: '12px' },
    'w': { left: -6, top: '50%', transform: 'translateY(-50%)', width: '12px', height: '60px' }
  };
  return positions[position];
};

const PlanogramProfitTracker = () => {
  const [fixtures, setFixtures] = useState([]);
  const [selectedFixture, setSelectedFixture] = useState(null);
  const [sections, setSections] = useState([]);
  const [selectedSection, setSelectedSection] = useState(null);
  const [selectedRow, setSelectedRow] = useState(null);
  const [scale, setScale] = useState(20);
  const [storeName, setStoreName] = useState('My Store Layout');
  const [newProduct, setNewProduct] = useState({ upc: '', sectionId: '', rowId: '' });
  const [scanning, setScanning] = useState(false);
  const [savedLayouts, setSavedLayouts] = useState([]);
  const [showSaveModal, setShowSaveModal] = useState(false);
  const [showLoadModal, setShowLoadModal] = useState(false);
  const [feedback, setFeedback] = useState('');
  const [timeFilter, setTimeFilter] = useState('monthly');
  const [sortBy, setSortBy] = useState('profit');
  const [showSettings, setShowSettings] = useState(false);
  const [shopifyConfig, setShopifyConfig] = useState({
    storeName: '1m3tfh-xt.myshopify.com',
    accessToken: '',
    connected: false
  });
  
  const [showLibrary, setShowLibrary] = useState(true);
  const [heatMapMode, setHeatMapMode] = useState(false);
  const [timePeriod, setTimePeriod] = useState('month'); // day, week, month, quarter, custom
  const [customDateRange, setCustomDateRange] = useState({ start: '', end: '' });
  const [backgroundImage, setBackgroundImage] = useState(null);
  const [bgImagePosition, setBgImagePosition] = useState({ x: 0, y: 0 });
  const [isDraggingBg, setIsDraggingBg] = useState(false);
  const [bgDragStart, setBgDragStart] = useState({ x: 0, y: 0 });
  const [showVisualMode, setShowVisualMode] = useState(true);
  const [editingSection, setEditingSection] = useState(null);
  const [editingSectionName, setEditingSectionName] = useState('');
  const [editingSectionArea, setEditingSectionArea] = useState(null);
  const [editingAreaValue, setEditingAreaValue] = useState('');
  const [lastRefresh, setLastRefresh] = useState(null);
  const [autoRefreshEnabled, setAutoRefreshEnabled] = useState(true);
  
  // Firebase states
  const [firebaseConfig, setFirebaseConfig] = useState({
    apiKey: 'AIzaSyBZ6qLt8KVgV877K6IBy0pwZ5a9y1FqGLY',
    authDomain: 'storeplannerpro.firebaseapp.com',
    projectId: 'storeplannerpro',
    storageBucket: 'storeplannerpro.firebasestorage.app',
    messagingSenderId: '339443807903',
    appId: '1:339443807903:web:f24e76cc784f7177b494aa'
  });
  const [firebaseInitialized, setFirebaseInitialized] = useState(false);
  const [cloudSyncEnabled, setCloudSyncEnabled] = useState(false);
  const [syncStatus, setSyncStatus] = useState('');
  const [showFirebaseSettings, setShowFirebaseSettings] = useState(false);
  
  const fileInputRef = useRef(null);
  const importInputRef = useRef(null);
  const firebaseRef = useRef(null);
  const dbRef = useRef(null);
  const [zoom, setZoom] = useState(1);
  const [panOffset, setPanOffset] = useState({ x: 0, y: 0 });
  const canvasRef = useRef(null);
  
  const BACKEND_URL = 'https://planogram-backend-gx85.onrender.com';
  
  const productDatabase = {
    '123456789012': { name: 'Premium Coffee Beans', price: 24.99, cost: 12.50, monthlySales: 145 },
    '234567890123': { name: 'Organic Tea Set', price: 18.99, cost: 9.00, monthlySales: 89 },
    '345678901234': { name: 'Artisan Chocolate', price: 12.99, cost: 6.50, monthlySales: 234 },
    '456789012345': { name: 'Gourmet Cookies', price: 8.99, cost: 4.00, monthlySales: 312 },
    '567890123456': { name: 'Specialty Honey', price: 15.99, cost: 7.50, monthlySales: 67 },
  };

  useEffect(() => {
    try {
      const savedSections = localStorage.getItem('planogram_sections');
      const savedFixtures = localStorage.getItem('planogram_fixtures');
      const savedBg = localStorage.getItem('planogram_background');
      const savedBgPos = localStorage.getItem('planogram_bg_position');
      const savedShopify = localStorage.getItem('planogram_shopify');
      const savedLastRefresh = localStorage.getItem('planogram_last_refresh');
      
      if (savedSections) setSections(JSON.parse(savedSections));
      if (savedFixtures) setFixtures(JSON.parse(savedFixtures));
      if (savedBg) setBackgroundImage(savedBg);
      if (savedBgPos) setBgImagePosition(JSON.parse(savedBgPos));
      if (savedShopify) {
        const config = JSON.parse(savedShopify);
        setShopifyConfig(config);
      }
      if (savedLastRefresh) {
        setLastRefresh(new Date(savedLastRefresh));
      }
    } catch (error) {
      console.error('Error loading saved data:', error);
    }
  }, []);

  // Auto-refresh every 5 minutes
  useEffect(() => {
    if (!autoRefreshEnabled || !shopifyConfig.connected) return;

    const interval = setInterval(() => {
      console.log('ðŸ”„ Auto-refreshing product data...');
      refreshProductCache(true);
    }, 5 * 60 * 1000); // 5 minutes

    return () => clearInterval(interval);
  }, [autoRefreshEnabled, shopifyConfig.connected]);

  const autoSave = (updatedSections, message = 'Auto-saved') => {
    try {
      localStorage.setItem('planogram_sections', JSON.stringify(updatedSections));
      localStorage.setItem('planogram_last_save', new Date().toISOString());
      console.log(`âœ… ${message}`);
      
      // Also save to Firebase if enabled
      if (cloudSyncEnabled && dbRef.current) {
        saveToFirebase(updatedSections);
      }
    } catch (error) {
      console.error('âŒ Auto-save failed:', error);
    }
  };

  // Firebase Functions
  const initializeFirebase = () => {
    try {
      const config = {
        apiKey: firebaseConfig.apiKey,
        authDomain: firebaseConfig.authDomain,
        projectId: firebaseConfig.projectId,
        storageBucket: firebaseConfig.storageBucket,
        messagingSenderId: firebaseConfig.messagingSenderId,
        appId: firebaseConfig.appId
      };

      if (!firebase.apps.length) {
        firebaseRef.current = firebase.initializeApp(config);
      } else {
        firebaseRef.current = firebase.app();
      }
      
      dbRef.current = firebase.firestore();
      setFirebaseInitialized(true);
      setSyncStatus('âœ… Firebase connected');
      setTimeout(() => setSyncStatus(''), 3000);
      
      // Save config to localStorage
      localStorage.setItem('planogram_firebase_config', JSON.stringify(firebaseConfig));
      
      return true;
    } catch (error) {
      console.error('Firebase initialization error:', error);
      setSyncStatus(`âŒ ${error.message}`);
      setTimeout(() => setSyncStatus(''), 5000);
      return false;
    }
  };

  const saveToFirebase = async (sectionsData) => {
    if (!dbRef.current || !cloudSyncEnabled) return;

    try {
      const layoutData = {
        storeName,
        fixtures,
        sections: sectionsData,
        backgroundImage: backgroundImage ? 'stored_separately' : null, // Don't store large base64 in Firestore
        bgImagePosition,
        lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
        version: 3
      };

      await dbRef.current.collection('planograms').doc('default').set(layoutData);
      console.log('â˜ï¸ Saved to Firebase');
    } catch (error) {
      console.error('Firebase save error:', error);
    }
  };

  const loadFromFirebase = async () => {
    if (!dbRef.current) return;

    try {
      setSyncStatus('ðŸ”„ Loading from cloud...');
      const doc = await dbRef.current.collection('planograms').doc('default').get();
      
      if (doc.exists) {
        const data = doc.data();
        if (data.storeName) setStoreName(data.storeName);
        if (data.fixtures) {
          setFixtures(data.fixtures);
          localStorage.setItem('planogram_fixtures', JSON.stringify(data.fixtures));
        }
        if (data.sections) {
          setSections(data.sections);
          localStorage.setItem('planogram_sections', JSON.stringify(data.sections));
        }
        if (data.bgImagePosition) {
          setBgImagePosition(data.bgImagePosition);
          localStorage.setItem('planogram_bg_position', JSON.stringify(data.bgImagePosition));
        }
        
        setSyncStatus('âœ… Loaded from cloud');
        setFeedback('âœ… Cloud data loaded!');
        setTimeout(() => {
          setSyncStatus('');
          setFeedback('');
        }, 3000);
      } else {
        setSyncStatus('âš ï¸ No cloud data found');
        setTimeout(() => setSyncStatus(''), 3000);
      }
    } catch (error) {
      console.error('Firebase load error:', error);
      setSyncStatus(`âŒ Load failed: ${error.message}`);
      setTimeout(() => setSyncStatus(''), 5000);
    }
  };

  const exportLayout = () => {
    const layoutData = {
      version: 3,
      storeName,
      fixtures,
      sections,
      backgroundImage,
      bgImagePosition,
      shopifyConfig: {
        storeName: shopifyConfig.storeName,
        connected: shopifyConfig.connected
      },
      exportDate: new Date().toISOString()
    };

    const dataStr = JSON.stringify(layoutData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = `planogram-${storeName.replace(/\s+/g, '-')}-${new Date().toISOString().split('T')[0]}.json`;
    link.click();
    
    URL.revokeObjectURL(url);
    
    setFeedback('âœ… Layout exported!');
    setTimeout(() => setFeedback(''), 3000);
  };

  const importLayout = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const layoutData = JSON.parse(e.target.result);
        
        if (layoutData.version !== 3) {
          setFeedback('âš ï¸ Old version file.');
        }
        
        if (layoutData.storeName) setStoreName(layoutData.storeName);
        if (layoutData.fixtures) {
          setFixtures(layoutData.fixtures);
          localStorage.setItem('planogram_fixtures', JSON.stringify(layoutData.fixtures));
        }
        if (layoutData.sections) {
          setSections(layoutData.sections);
          localStorage.setItem('planogram_sections', JSON.stringify(layoutData.sections));
        }
        if (layoutData.backgroundImage) {
          setBackgroundImage(layoutData.backgroundImage);
          localStorage.setItem('planogram_background', layoutData.backgroundImage);
        }
        if (layoutData.bgImagePosition) {
          setBgImagePosition(layoutData.bgImagePosition);
          localStorage.setItem('planogram_bg_position', JSON.stringify(layoutData.bgImagePosition));
        }
        
        setFeedback('âœ… Layout imported!');
        setTimeout(() => setFeedback(''), 3000);
        
      } catch (error) {
        console.error('Import error:', error);
        setFeedback('âŒ Failed to import. Invalid file.');
        setTimeout(() => setFeedback(''), 5000);
      }
    };
    
    reader.readAsText(file);
    event.target.value = '';
  };

  const handleBgMouseDown = (e) => {
    if (e.target.tagName !== 'IMG') return;
    setIsDraggingBg(true);
    setBgDragStart({
      x: e.clientX - bgImagePosition.x,
      y: e.clientY - bgImagePosition.y
    });
    e.preventDefault();
    e.stopPropagation();
  };

  const handleBgMouseMove = (e) => {
    if (!isDraggingBg) return;
    setBgImagePosition({
      x: e.clientX - bgDragStart.x,
      y: e.clientY - bgDragStart.y
    });
  };

  const handleBgMouseUp = () => {
    if (isDraggingBg) {
      setIsDraggingBg(false);
      try {
        localStorage.setItem('planogram_bg_position', JSON.stringify(bgImagePosition));
      } catch (error) {
        console.error('Failed to save background position:', error);
      }
    }
  };

  const resetBackgroundPosition = () => {
    const resetPos = { x: 0, y: 0 };
    setBgImagePosition(resetPos);
    localStorage.setItem('planogram_bg_position', JSON.stringify(resetPos));
    setFeedback('âœ… Background reset');
    setTimeout(() => setFeedback(''), 2000);
  };

  const testShopifyConnection = async () => {
    if (!shopifyConfig.storeName || !shopifyConfig.accessToken) {
      setFeedback('âš ï¸ Enter store name and token');
      setTimeout(() => setFeedback(''), 3000);
      return;
    }

    setFeedback('ðŸ”„ Testing...');

    try {
      const response = await fetch(`${BACKEND_URL}/api/shopify`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          storeName: shopifyConfig.storeName,
          accessToken: shopifyConfig.accessToken,
          action: 'connect'
        })
      });

      const data = await response.json();

      if (response.ok && data.success) {
        const updatedConfig = { ...shopifyConfig, connected: true };
        setShopifyConfig(updatedConfig);
        localStorage.setItem('planogram_shopify', JSON.stringify(updatedConfig));
        setFeedback(`âœ… Connected!`);
        setTimeout(() => {
          setFeedback('');
          setShowSettings(false);
        }, 2000);
      } else {
        setFeedback(`âŒ ${data.error || 'Failed'}`);
        setTimeout(() => setFeedback(''), 5000);
      }
    } catch (error) {
      console.error('Connection error:', error);
      setFeedback('âŒ Connection error');
      setTimeout(() => setFeedback(''), 5000);
    }
  };

  const disconnectShopify = () => {
    const updatedConfig = {
      storeName: shopifyConfig.storeName,
      accessToken: '',
      connected: false
    };
    setShopifyConfig(updatedConfig);
    localStorage.setItem('planogram_shopify', JSON.stringify(updatedConfig));
    setFeedback('âœ… Disconnected');
    setTimeout(() => setFeedback(''), 2000);
  };

  const refreshProductCache = async (isAutoRefresh = false) => {
    if (!shopifyConfig.connected || !shopifyConfig.accessToken) {
      if (!isAutoRefresh) {
        setFeedback('âš ï¸ Connect to Shopify first');
        setTimeout(() => setFeedback(''), 3000);
      }
      return;
    }

    if (!isAutoRefresh) {
      setFeedback('ðŸ”„ Refreshing...');
    }
    
    try {
      const response = await fetch(`${BACKEND_URL}/api/shopify`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          storeName: shopifyConfig.storeName,
          accessToken: shopifyConfig.accessToken,
          action: 'refreshCache'
        })
      });

      const data = await response.json();

      if (response.ok && data.success) {
        const now = new Date();
        setLastRefresh(now);
        localStorage.setItem('planogram_last_refresh', now.toISOString());
        
        if (!isAutoRefresh) {
          setFeedback(`âœ… ${data.message}`);
          setTimeout(() => setFeedback(''), 5000);
        } else {
          console.log('âœ… Auto-refresh completed at', now.toLocaleTimeString());
        }
      } else {
        if (!isAutoRefresh) {
          setFeedback(`âŒ ${data.error || 'Failed'}`);
          setTimeout(() => setFeedback(''), 5000);
        }
      }
    } catch (error) {
      if (!isAutoRefresh) {
        setFeedback('âŒ Cache refresh failed');
        setTimeout(() => setFeedback(''), 5000);
      }
      console.error('Auto-refresh error:', error);
    }
  };

  const addProductToSection = async () => {
    if (!newProduct.upc || !newProduct.sectionId || !newProduct.rowId) {
      setFeedback('âš ï¸ Enter UPC and select section & row');
      setTimeout(() => setFeedback(''), 3000);
      return;
    }

    setScanning(true);
    const sectionIndex = sections.findIndex(s => s.id === newProduct.sectionId);
    
    if (sectionIndex === -1) {
      setFeedback('âš ï¸ Section not found');
      setScanning(false);
      return;
    }

    let product = null;
    
    if (shopifyConfig.connected) {
      try {
        const response = await fetch(`${BACKEND_URL}/api/product/${newProduct.upc}`);
        const data = await response.json();

        if (response.ok && data.title) {
          product = {
            upc: newProduct.upc,
            name: data.variantTitle ? `${data.title} - ${data.variantTitle}` : data.title,
            price: data.price,
            cost: data.cost,
            dailySales: data.dailySales || 0,
            weeklySales: data.weeklySales || 0,
            monthlySales: data.monthlySales || 0,
            quarterlySales: data.quarterlySales || 0,
            yearlySales: data.yearlySales || 0,
            allTimeSales: data.allTimeSales || 0,
            quantity: 1,
            source: 'database',
            visualX: Math.random() * 80 + 10,
            visualY: Math.random() * 80 + 10
          };
          setFeedback(`âœ… Added: ${product.name} (${data.monthlySales || 0} monthly sales)`);
        }
      } catch (error) {
        console.error('Error fetching from database:', error);
      }
    }
    
    if (!product && productDatabase[newProduct.upc]) {
      product = { 
        upc: newProduct.upc, 
        ...productDatabase[newProduct.upc],
        quantity: 1,
        source: 'sample',
        visualX: Math.random() * 80 + 10,
        visualY: Math.random() * 80 + 10
      };
      setFeedback(`âœ… Added: ${product.name} (Sample)`);
    }
    
    if (!product) {
      product = {
        upc: newProduct.upc,
        name: `Product ${newProduct.upc.slice(-4)}`,
        price: 0,
        cost: 0,
        monthlySales: 0,
        quantity: 1,
        source: 'placeholder',
        visualX: Math.random() * 80 + 10,
        visualY: Math.random() * 80 + 10
      };
      setFeedback('âš ï¸ Not found - placeholder added');
    }

    // Add product to the specified row
    const updatedSections = [...sections];
    const section = updatedSections[sectionIndex];
    const rowIndex = (section.rows || []).findIndex(r => r.id === newProduct.rowId);
    
    if (rowIndex >= 0) {
      section.rows[rowIndex].products.push(product);
    } else {
      // Fallback: add to section products if row not found
      if (!section.products) section.products = [];
      section.products.push(product);
    }
    
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved after adding product');

    setScanning(false);
    setNewProduct({ upc: '', sectionId: '', rowId: '' });
    setTimeout(() => setFeedback(''), 3000);
  };

  const updateProductQuantity = (sectionId, productIndex, delta) => {
    const updatedSections = sections.map(section => {
      if (section.id === sectionId) {
        const updatedProducts = [...section.products];
        updatedProducts[productIndex] = {
          ...updatedProducts[productIndex],
          quantity: Math.max(0, updatedProducts[productIndex].quantity + delta)
        };
        return { ...section, products: updatedProducts };
      }
      return section;
    });
    
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved after quantity update');
  };

  const updateProductPosition = (sectionId, productIndex, newX, newY) => {
    const updatedSections = sections.map(section => {
      if (section.id === sectionId) {
        const updatedProducts = [...section.products];
        updatedProducts[productIndex] = {
          ...updatedProducts[productIndex],
          visualX: newX,
          visualY: newY
        };
        return { ...section, products: updatedProducts };
      }
      return section;
    });
    
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved product position');
  };

  const deleteProduct = (sectionId, productIndex) => {
    if (!confirm('Delete this product?')) return;

    const updatedSections = sections.map(section => {
      if (section.id === sectionId) {
        const updatedProducts = section.products.filter((_, idx) => idx !== productIndex);
        return { ...section, products: updatedProducts };
      }
      return section;
    });
    
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved after deleting product');
    
    setFeedback('âœ… Product deleted');
    setTimeout(() => setFeedback(''), 2000);
  };

  const addFixture = (type) => {
    const fixtureType = FIXTURE_TYPES[type];
    const newFixture = {
      id: `fixture-${Date.now()}`,
      type: fixtureType.id,
      name: fixtureType.name,
      x: 100,
      y: 100,
      width: fixtureType.defaultWidth,
      height: fixtureType.defaultHeight,
      color: fixtureType.color,
      sections: []
    };
    
    const updatedFixtures = [...fixtures, newFixture];
    setFixtures(updatedFixtures);
    localStorage.setItem('planogram_fixtures', JSON.stringify(updatedFixtures));
    setSelectedFixture(newFixture.id);
  };

  const deleteFixture = (fixtureId) => {
    if (!confirm('Delete fixture and all sections?')) return;
    
    const updatedFixtures = fixtures.filter(f => f.id !== fixtureId);
    setFixtures(updatedFixtures);
    localStorage.setItem('planogram_fixtures', JSON.stringify(updatedFixtures));
    
    const updatedSections = sections.filter(s => s.fixtureId !== fixtureId);
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved after deleting fixture');
    
    if (selectedFixture === fixtureId) {
      setSelectedFixture(null);
    }
  };

  const updateFixture = (updatedFixture) => {
    const updatedFixtures = fixtures.map(f => 
      f.id === updatedFixture.id ? updatedFixture : f
    );
    setFixtures(updatedFixtures);
    localStorage.setItem('planogram_fixtures', JSON.stringify(updatedFixtures));
  };

  const addSection = (fixtureId) => {
    const fixture = fixtures.find(f => f.id === fixtureId);
    if (!fixture) return;

    const existingSections = sections.filter(s => s.fixtureId === fixtureId);

    // Smart default positioning - try to fit new section without overlap
    const numExisting = existingSections.length;
    let defaultX = 0;
    let defaultY = 0;
    let defaultWidth = 100;
    let defaultHeight = 100;

    if (numExisting > 0) {
      // Place new sections in rows
      const sectionsPerRow = 2;
      const row = Math.floor(numExisting / sectionsPerRow);
      const col = numExisting % sectionsPerRow;
      
      defaultWidth = 50;
      defaultHeight = 50;
      defaultX = col * 50;
      defaultY = row * 50;
    }

    const newSection = {
      id: `section-${Date.now()}`,
      fixtureId: fixtureId,
      name: `Section ${existingSections.length + 1}`,
      products: [],
      area: 10,
      // Position and size within fixture (percentage-based 0-100)
      layoutX: defaultX,
      layoutY: defaultY,
      layoutWidth: defaultWidth,
      layoutHeight: defaultHeight,
      // NEW: Rows for height tracking
      rows: [
        { id: `row-${Date.now()}-1`, name: 'Top', products: [] },
        { id: `row-${Date.now()}-2`, name: 'Middle', products: [] },
        { id: `row-${Date.now()}-3`, name: 'Bottom', products: [] }
      ]
    };

    const updatedSections = [...sections, newSection];
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved after adding section');
  };

  const deleteSection = (sectionId) => {
    if (!confirm('Delete section and all products?')) return;
    
    const updatedSections = sections.filter(s => s.id !== sectionId);
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved after deleting section');
    
    if (selectedSection === sectionId) {
      setSelectedSection(null);
    }
  };

  const updateSectionName = (sectionId, newName) => {
    const updatedSections = sections.map(section => {
      if (section.id === sectionId) {
        return { ...section, name: newName };
      }
      return section;
    });
    
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved after renaming section');
    setEditingSection(null);
    setFeedback('âœ… Section renamed');
    setTimeout(() => setFeedback(''), 2000);
  };

  const updateSectionArea = (sectionId, newArea) => {
    const area = parseFloat(newArea);
    if (isNaN(area) || area <= 0) {
      setFeedback('âš ï¸ Area must be a positive number');
      setTimeout(() => setFeedback(''), 2000);
      return;
    }

    const updatedSections = sections.map(section => {
      if (section.id === sectionId) {
        return { ...section, area };
      }
      return section;
    });
    
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved after updating area');
    setEditingSectionArea(null);
    setFeedback('âœ… Area updated');
    setTimeout(() => setFeedback(''), 2000);
  };

  const updateSection = (updatedSection) => {
    const updatedSections = sections.map(s => 
      s.id === updatedSection.id ? updatedSection : s
    );
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved section layout');
  };

  // NEW: Row management functions
  const addRowToSection = (sectionId) => {
    const updatedSections = sections.map(section => {
      if (section.id === sectionId) {
        const rows = section.rows || [];
        const newRow = {
          id: `row-${Date.now()}`,
          name: `Row ${rows.length + 1}`,
          products: []
        };
        return {
          ...section,
          rows: [...rows, newRow]
        };
      }
      return section;
    });
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved after adding row');
    setFeedback('âœ… Row added');
    setTimeout(() => setFeedback(''), 2000);
  };

  const deleteRow = (sectionId, rowId) => {
    if (!confirm('Delete row and all products in it?')) return;
    
    const updatedSections = sections.map(section => {
      if (section.id === sectionId) {
        return {
          ...section,
          rows: (section.rows || []).filter(r => r.id !== rowId)
        };
      }
      return section;
    });
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved after deleting row');
    setFeedback('âœ… Row deleted');
    setTimeout(() => setFeedback(''), 2000);
  };

  const updateRowName = (sectionId, rowId, newName) => {
    const updatedSections = sections.map(section => {
      if (section.id === sectionId) {
        return {
          ...section,
          rows: (section.rows || []).map(row => 
            row.id === rowId ? { ...row, name: newName } : row
          )
        };
      }
      return section;
    });
    setSections(updatedSections);
    autoSave(updatedSections, 'Auto-saved after renaming row');
  };

  const handleBackgroundUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const imageData = event.target.result;
        setBackgroundImage(imageData);
        localStorage.setItem('planogram_background', imageData);
        setFeedback('âœ… Background uploaded');
        setTimeout(() => setFeedback(''), 2000);
      };
      reader.readAsDataURL(file);
    }
  };

  const removeBackground = () => {
    setBackgroundImage(null);
    setBgImagePosition({ x: 0, y: 0 });
    localStorage.removeItem('planogram_background');
    localStorage.removeItem('planogram_bg_position');
    setFeedback('âœ… Background removed');
    setTimeout(() => setFeedback(''), 2000);
  };

  const calculateMetrics = (section, timePeriodFilter) => {
    const area = section.area || 1;

    const productMetrics = section.products.map(p => {
      // Use the appropriate sales field based on time period
      let salesVolume = 0;
      switch(timePeriodFilter) {
        case 'day':
          salesVolume = p.dailySales || 0;
          break;
        case 'week':
          salesVolume = p.weeklySales || 0;
          break;
        case 'month':
          salesVolume = p.monthlySales || 0;
          break;
        case 'quarter':
          salesVolume = p.quarterlySales || 0;
          break;
        case 'year':
          salesVolume = p.yearlySales || 0;
          break;
        case 'all':
          salesVolume = p.allTimeSales || 0;
          break;
        case 'custom':
          // For custom, use monthly as default (would need custom logic to calculate actual range)
          salesVolume = p.monthlySales || 0;
          break;
        default:
          salesVolume = p.monthlySales || 0;
      }

      const periodRevenue = p.price * salesVolume;
      const periodProfit = (p.price - p.cost) * salesVolume;
      const velocity = salesVolume / area;

      return { ...p, periodVolume: salesVolume, periodRevenue, periodProfit, velocity };
    });

    productMetrics.sort((a, b) => {
      switch(sortBy) {
        case 'profit': return b.periodProfit - a.periodProfit;
        case 'revenue': return b.periodRevenue - a.periodRevenue;
        case 'velocity': return b.velocity - a.velocity;
        case 'volume': return b.periodVolume - a.periodVolume;
        case 'name': return a.name.localeCompare(b.name);
        default: return 0;
      }
    });
    
    const totalRevenue = productMetrics.reduce((sum, p) => sum + p.periodRevenue, 0);
    const totalCost = productMetrics.reduce((sum, p) => sum + (p.cost * p.periodVolume), 0);
    const totalProfit = productMetrics.reduce((sum, p) => sum + p.periodProfit, 0);
    const totalVolume = productMetrics.reduce((sum, p) => sum + p.periodVolume, 0);
    const totalVelocity = productMetrics.reduce((sum, p) => sum + p.velocity, 0);
    const profitPerSqFt = area > 0 ? totalProfit / area : 0;

    return { area, totalRevenue, totalCost, totalProfit, profitPerSqFt, totalVolume, totalVelocity, productMetrics };
  };

  const getHeatMapColor = (profitPerSqFt) => {
    const maxProfit = Math.max(...sections.map(s => calculateMetrics(s, timePeriod).profitPerSqFt));
    const intensity = maxProfit > 0 ? profitPerSqFt / maxProfit : 0;
    
    if (intensity > 0.7) return 'rgba(34, 197, 94, 0.6)';
    if (intensity > 0.4) return 'rgba(234, 179, 8, 0.6)';
    if (intensity > 0.1) return 'rgba(249, 115, 22, 0.6)';
    return 'rgba(239, 68, 68, 0.6)';
  };

  const ProductBox = ({ product, productIndex, sectionId, fixtureX, fixtureY, fixtureWidth, fixtureHeight }) => {
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e) => {
      e.stopPropagation();
      setIsDragging(true);
      setDragStart({ x: e.clientX, y: e.clientY });
    };

    useEffect(() => {
      if (!isDragging) return;

      const handleMouseMove = (e) => {
        const deltaX = e.clientX - dragStart.x;
        const deltaY = e.clientY - dragStart.y;
        
        const newX = Math.max(5, Math.min(95, ((product.visualX / 100) * fixtureWidth + deltaX) / fixtureWidth * 100));
        const newY = Math.max(5, Math.min(95, ((product.visualY / 100) * fixtureHeight + deltaY) / fixtureHeight * 100));
        
        updateProductPosition(sectionId, productIndex, newX, newY);
        setDragStart({ x: e.clientX, y: e.clientY });
      };

      const handleMouseUp = () => {
        setIsDragging(false);
      };

      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);

      return () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
    }, [isDragging, dragStart]);

    const profit = (product.price - product.cost) * (product.monthlySales || 0);
    let colorClass = 'bg-gray-400';
    if (profit > 100) colorClass = 'bg-green-500';
    else if (profit > 50) colorClass = 'bg-yellow-500';
    else if (profit > 0) colorClass = 'bg-orange-500';
    else if (profit < 0) colorClass = 'bg-red-500';

    const size = Math.min(Math.max(20, 15 + product.quantity * 3), 40);

    return (
      <div
        className={`absolute ${colorClass} rounded shadow-lg flex items-center justify-center text-white text-xs font-bold cursor-move hover:opacity-80`}
        style={{
          left: `${product.visualX}%`,
          top: `${product.visualY}%`,
          width: `${size}px`,
          height: `${size}px`,
          transform: 'translate(-50%, -50%)',
          zIndex: isDragging ? 1000 : 50,
          pointerEvents: 'auto'
        }}
        onMouseDown={handleMouseDown}
        title={`${product.name}\n$${product.price}\nQty: ${product.quantity}\nProfit: $${profit.toFixed(2)}`}
      >
        {product.quantity}
      </div>
    );
  };

  const DraggableSection = ({ section, fixture, isSelected, onSelect }) => {
    const [isDragging, setIsDragging] = useState(false);
    const [isResizing, setIsResizing] = useState(false);
    
    const metrics = calculateMetrics(section, timePeriod);
    const color = heatMapMode ? getHeatMapColor(metrics.profitPerSqFt) : 'rgba(100, 116, 139, 0.3)';
    
    // Use custom layout properties or default to full fixture
    const layoutX = section.layoutX !== undefined ? section.layoutX : 0;
    const layoutY = section.layoutY !== undefined ? section.layoutY : 0;
    const layoutWidth = section.layoutWidth !== undefined ? section.layoutWidth : 100;
    const layoutHeight = section.layoutHeight !== undefined ? section.layoutHeight : 100;
    
    const handleMouseDown = (e) => {
      if (e.target.classList.contains('section-resize-handle')) {
        e.stopPropagation();
        setIsResizing(true);
        const resizePosition = e.target.dataset.position;
        const startX = e.clientX;
        const startY = e.clientY;
        const startLayoutX = layoutX;
        const startLayoutY = layoutY;
        const startLayoutWidth = layoutWidth;
        const startLayoutHeight = layoutHeight;

        const handleMouseMove = (e) => {
          const deltaX = ((e.clientX - startX) / fixture.width) * 100;
          const deltaY = ((e.clientY - startY) / fixture.height) * 100;

          let newLayoutX = startLayoutX;
          let newLayoutY = startLayoutY;
          let newLayoutWidth = startLayoutWidth;
          let newLayoutHeight = startLayoutHeight;

          if (resizePosition.includes('e')) {
            newLayoutWidth = Math.max(10, Math.min(100 - startLayoutX, startLayoutWidth + deltaX));
          }
          if (resizePosition.includes('w')) {
            const widthChange = Math.max(10, startLayoutWidth - deltaX);
            newLayoutWidth = widthChange;
            newLayoutX = startLayoutX + (startLayoutWidth - widthChange);
          }
          if (resizePosition.includes('s')) {
            newLayoutHeight = Math.max(10, Math.min(100 - startLayoutY, startLayoutHeight + deltaY));
          }
          if (resizePosition.includes('n')) {
            const heightChange = Math.max(10, startLayoutHeight - deltaY);
            newLayoutHeight = heightChange;
            newLayoutY = startLayoutY + (startLayoutHeight - heightChange);
          }

          updateSection({
            ...section,
            layoutX: Math.max(0, Math.min(100 - newLayoutWidth, newLayoutX)),
            layoutY: Math.max(0, Math.min(100 - newLayoutHeight, newLayoutY)),
            layoutWidth: newLayoutWidth,
            layoutHeight: newLayoutHeight
          });
        };

        const handleMouseUp = () => {
          setIsResizing(false);
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        };

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        return;
      }

      // Handle dragging
      e.stopPropagation();
      setIsDragging(true);
      onSelect();
      
      const startX = e.clientX;
      const startY = e.clientY;
      const startLayoutX = layoutX;
      const startLayoutY = layoutY;

      const handleMouseMove = (e) => {
        const deltaX = ((e.clientX - startX) / fixture.width) * 100;
        const deltaY = ((e.clientY - startY) / fixture.height) * 100;
        
        updateSection({
          ...section,
          layoutX: Math.max(0, Math.min(100 - layoutWidth, startLayoutX + deltaX)),
          layoutY: Math.max(0, Math.min(100 - layoutHeight, startLayoutY + deltaY))
        });
      };

      const handleMouseUp = () => {
        setIsDragging(false);
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };

      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    };

    // Calculate actual pixel positions
    const left = (layoutX / 100) * fixture.width;
    const top = (layoutY / 100) * fixture.height;
    const width = (layoutWidth / 100) * fixture.width;
    const height = (layoutHeight / 100) * fixture.height;

    return (
      <div
        style={{
          position: 'absolute',
          left: left,
          top: top,
          width: width,
          height: height,
          backgroundColor: color,
          border: isSelected ? '2px solid #3b82f6' : '1px solid rgba(255,255,255,0.5)',
          cursor: isDragging ? 'grabbing' : 'grab',
          pointerEvents: 'auto',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          fontSize: width > 60 && height > 40 ? '11px' : '9px',
          color: 'white',
          fontWeight: 'bold',
          textShadow: '1px 1px 2px rgba(0,0,0,0.8)',
          zIndex: isSelected ? 60 : 40,
          overflow: 'hidden'
        }}
        onMouseDown={handleMouseDown}
      >
        {/* Only show label if section is big enough */}
        {width > 40 && height > 30 && (
          <div className="text-center pointer-events-none" style={{ maxWidth: '90%', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
            <div>{section.name}</div>
            {heatMapMode && width > 60 && <div>${metrics.profitPerSqFt.toFixed(0)}/sqft</div>}
          </div>
        )}

        {/* Resize handles - only show when selected */}
        {isSelected && ['nw', 'ne', 'se', 'sw', 'n', 's', 'e', 'w'].map(position => (
          <div
            key={position}
            className="section-resize-handle"
            data-position={position}
            style={{
              position: 'absolute',
              background: '#3b82f6',
              border: '1px solid white',
              cursor: getCursor(position),
              zIndex: 70,
              pointerEvents: 'auto',
              ...getHandlePosition(position)
            }}
          />
        ))}
      </div>
    );
  };

const Fixture = ({ fixture, onUpdate, onDelete, onSelect, isSelected }) => {
    const [dragging, setDragging] = useState(false);

    const handleMouseDown = (e) => {
      if (e.target.classList.contains('resize-handle')) {
        e.stopPropagation();
        const resizePosition = e.target.dataset.position;
        const startX = e.clientX;
        const startY = e.clientY;
        const startWidth = fixture.width;
        const startHeight = fixture.height;
        const startLeft = fixture.x;
        const startTop = fixture.y;

        const handleMouseMove = (e) => {
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;

          let newWidth = startWidth;
          let newHeight = startHeight;
          let newX = startLeft;
          let newY = startTop;

          if (resizePosition.includes('e')) newWidth = Math.max(60, startWidth + deltaX);
          if (resizePosition.includes('w')) {
            newWidth = Math.max(60, startWidth - deltaX);
            newX = startLeft + (startWidth - newWidth);
          }
          if (resizePosition.includes('s')) newHeight = Math.max(60, startHeight + deltaY);
          if (resizePosition.includes('n')) {
            newHeight = Math.max(60, startHeight - deltaY);
            newY = startTop + (startHeight - newHeight);
          }

          onUpdate({ ...fixture, width: newWidth, height: newHeight, x: newX, y: newY });
        };

        const handleMouseUp = () => {
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        };

        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        return;
      }

      e.stopPropagation();
      setDragging(true);
      onSelect();
      
      const startX = e.clientX;
      const startY = e.clientY;
      const startLeft = fixture.x;
      const startTop = fixture.y;

      const handleMouseMove = (e) => {
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        onUpdate({ ...fixture, x: startLeft + deltaX, y: startTop + deltaY });
      };

      const handleMouseUp = () => {
        setDragging(false);
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };

      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    };

    const fixtureSections = sections.filter(s => s.fixtureId === fixture.id);
    const totalProfit = fixtureSections.reduce((sum, s) => {
      const metrics = calculateMetrics(s, timePeriod);
      return sum + metrics.totalProfit;
    }, 0);

    return (
      <div
        style={{
          position: 'absolute',
          left: fixture.x,
          top: fixture.y,
          width: fixture.width,
          height: fixture.height,
          backgroundColor: fixture.color,
          border: isSelected ? '3px solid #3b82f6' : '2px solid #cbd5e1',
          borderRadius: '8px',
          cursor: dragging ? 'grabbing' : 'grab',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          opacity: heatMapMode ? 0.95 : 0.9,
          zIndex: isSelected ? 100 : 10,
          overflow: 'hidden'
        }}
        onMouseDown={handleMouseDown}
      >
        {/* Draggable/Resizable Sections - always visible */}
        {fixtureSections.map(section => (
          <DraggableSection
            key={section.id}
            section={section}
            fixture={fixture}
            isSelected={selectedSection === section.id}
            onSelect={() => setSelectedSection(section.id)}
          />
        ))}

        {/* Fixture label - only show when NOT in heat map mode */}
        {!heatMapMode && (
          <div className="text-white text-center p-2 pointer-events-none">
            <div className="font-bold text-sm">{fixture.name}</div>
            <div className="text-xs">{fixtureSections.length} sections</div>
          </div>
        )}

        {showVisualMode && fixtureSections.map(section => 
          section.products.map((product, idx) => (
            <ProductBox
              key={`${section.id}-${idx}`}
              product={product}
              productIndex={idx}
              sectionId={section.id}
              fixtureX={fixture.x}
              fixtureY={fixture.y}
              fixtureWidth={fixture.width}
              fixtureHeight={fixture.height}
            />
          ))
        )}

        {isSelected && (
          <button
            onClick={(e) => {
              e.stopPropagation();
              onDelete(fixture.id);
            }}
            className="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600"
            style={{ pointerEvents: 'auto' }}
          >
            <Icons.X />
          </button>
        )}

        {isSelected && ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'].map(position => (
          <div
            key={position}
            className="resize-handle"
            data-position={position}
            style={{
              position: 'absolute',
              background: 'white',
              border: '2px solid #3b82f6',
              cursor: getCursor(position),
              zIndex: 110,
              pointerEvents: 'auto',
              ...getHandlePosition(position)
            }}
          />
        ))}
      </div>
    );
  };

  return (
    <div className="flex h-screen bg-gray-100">
      {showLibrary && (
        <div className="w-64 bg-white shadow-lg p-4 overflow-y-auto">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-xl font-bold flex items-center gap-2">
              <Icons.Package />
              Fixture Library
            </h2>
            <button onClick={() => setShowLibrary(false)} className="p-1 hover:bg-gray-100 rounded">
              <Icons.X />
            </button>
          </div>

          <div className="space-y-2">
            {Object.entries(FIXTURE_TYPES).map(([key, type]) => {
              const IconComponent = Icons[type.icon];
              return (
                <button
                  key={key}
                  onClick={() => addFixture(key)}
                  className="w-full flex items-center gap-3 p-3 bg-gray-50 hover:bg-gray-100 rounded-lg border border-gray-200"
                >
                  <div className="w-10 h-10 rounded flex items-center justify-center" style={{ backgroundColor: type.color }}>
                    {IconComponent && <IconComponent />}
                  </div>
                  <span className="font-medium">{type.name}</span>
                </button>
              );
            })}
          </div>

          <div className="mt-6 pt-6 border-t">
            <h3 className="font-bold mb-2">Active Fixtures</h3>
            <div className="space-y-1">
              {fixtures.map(fixture => (
                <div
                  key={fixture.id}
                  className={`p-2 rounded cursor-pointer flex items-center justify-between ${
                    selectedFixture === fixture.id ? 'bg-blue-100' : 'hover:bg-gray-100'
                  }`}
                  onClick={() => setSelectedFixture(fixture.id)}
                >
                  <span className="text-sm">{fixture.name}</span>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      deleteFixture(fixture.id);
                    }}
                    className="text-red-500 hover:text-red-700"
                  >
                    <Icons.Trash2 />
                  </button>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      <div className="flex-1 flex flex-col">
        <div className="bg-white shadow-md p-4 flex items-center justify-between flex-wrap gap-2">
          <div className="flex items-center gap-2 flex-wrap">
            {!showLibrary && (
              <button onClick={() => setShowLibrary(true)} className="px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm">
                Show Library
              </button>
            )}
            
            <button
              onClick={() => setHeatMapMode(!heatMapMode)}
              className={`px-3 py-2 rounded flex items-center gap-2 text-sm ${heatMapMode ? 'bg-orange-500 text-white' : 'bg-gray-200'}`}
            >
              <Icons.Flame />
              Heat Map
            </button>

            {/* Time Period Filter */}
            <div className="flex items-center gap-2 bg-gradient-to-r from-blue-50 to-purple-50 px-3 py-2 rounded-lg border border-blue-200">
              <Icons.BarChart3 />
              <span className="text-sm font-semibold text-gray-700">Period:</span>
              <select
                value={timePeriod}
                onChange={(e) => setTimePeriod(e.target.value)}
                className="px-2 py-1 bg-white border-2 border-blue-300 rounded text-sm font-medium hover:border-blue-500 focus:outline-none focus:border-blue-600 cursor-pointer"
              >
                <option value="day">Today</option>
                <option value="week">This Week</option>
                <option value="month">This Month</option>
                <option value="quarter">This Quarter</option>
                <option value="year">This Year</option>
                <option value="all">All Time</option>
              </select>
            </div>

            <button
              onClick={() => setShowVisualMode(!showVisualMode)}
              className={`px-3 py-2 rounded flex items-center gap-2 text-sm ${showVisualMode ? 'bg-purple-500 text-white' : 'bg-gray-200'}`}
            >
              <Icons.Eye />
              Visual
            </button>

            <input type="file" ref={fileInputRef} onChange={handleBackgroundUpload} accept="image/*" className="hidden" />
            
            <button onClick={() => fileInputRef.current?.click()} className="px-3 py-2 bg-gray-200 rounded hover:bg-gray-300 flex items-center gap-2 text-sm">
              <Icons.Camera />
              BG
            </button>

            {backgroundImage && (
              <>
                <button onClick={removeBackground} className="px-3 py-2 bg-red-500 text-white rounded hover:bg-red-600 text-sm">
                  Remove
                </button>
                <button onClick={resetBackgroundPosition} className="px-3 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 flex items-center gap-2 text-sm">
                  <Icons.Move />
                  Reset
                </button>
              </>
            )}

            <button onClick={exportLayout} className="px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600 flex items-center gap-2 text-sm">
              <Icons.Download />
              Export
            </button>

            <input type="file" ref={importInputRef} onChange={importLayout} accept=".json" className="hidden" />
            
            <button onClick={() => importInputRef.current?.click()} className="px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 flex items-center gap-2 text-sm">
              <Icons.Upload />
              Import
            </button>

            <button onClick={() => setShowSettings(true)} className="px-3 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 text-sm">
              Shopify
            </button>

            {/* Time Period Filter */}
            <div className="flex items-center gap-2 bg-gradient-to-r from-blue-50 to-purple-50 px-3 py-2 rounded-lg border border-blue-200">
              <Icons.BarChart3 />
              <span className="text-sm font-semibold text-gray-700">Period:</span>
              <select
                value={timePeriod}
                onChange={(e) => setTimePeriod(e.target.value)}
                className="px-2 py-1 bg-white border-2 border-blue-300 rounded text-sm font-medium hover:border-blue-500 focus:outline-none focus:border-blue-600 cursor-pointer"
              >
                <option value="day">Today</option>
                <option value="week">This Week</option>
                <option value="month">This Month</option>
                <option value="quarter">This Quarter</option>
                <option value="year">This Year</option>
                <option value="all">All Time</option>
                <option value="custom">Custom Range</option>
              </select>
            </div>

            {/* Custom Date Range Picker */}
            {timePeriod === 'custom' && (
              <div className="flex items-center gap-2 bg-gradient-to-r from-purple-50 to-pink-50 px-3 py-2 rounded-lg border border-purple-300">
                <input
                  type="date"
                  value={customDateRange.start}
                  onChange={(e) => setCustomDateRange({...customDateRange, start: e.target.value})}
                  className="px-2 py-1 border-2 border-purple-300 rounded text-sm focus:outline-none focus:border-purple-500"
                />
                <span className="text-sm font-semibold text-gray-600">to</span>
                <input
                  type="date"
                  value={customDateRange.end}
                  onChange={(e) => setCustomDateRange({...customDateRange, end: e.target.value})}
                  className="px-2 py-1 border-2 border-purple-300 rounded text-sm focus:outline-none focus:border-purple-500"
                />
              </div>
            )}

            {shopifyConfig.connected && (
              <div className="flex items-center gap-2 px-3 py-2 bg-gray-100 rounded text-xs">
                <button
                  onClick={() => setAutoRefreshEnabled(!autoRefreshEnabled)}
                  className={`px-2 py-1 rounded ${autoRefreshEnabled ? 'bg-green-500 text-white' : 'bg-gray-300'}`}
                  title="Toggle auto-refresh"
                >
                  {autoRefreshEnabled ? 'ðŸ”„ Auto' : 'â¸ï¸ Paused'}
                </button>
                <button
                  onClick={() => refreshProductCache(false)}
                  className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 font-semibold"
                  title="Manually refresh Shopify data now"
                >
                  <Icons.RefreshCw /> Refresh Now
                </button>
                {lastRefresh && (
                  <span className="text-gray-600">
                    Updated: {lastRefresh.toLocaleTimeString()}
                  </span>
                )}
              </div>
            )}
          </div>

          <div className="text-xl font-bold">{storeName}</div>

          {feedback && (
            <div className="px-4 py-2 bg-blue-100 text-blue-800 rounded-lg text-sm">
              {feedback}
            </div>
          )}
        </div>

        <div 
          ref={canvasRef}
          className="flex-1 relative overflow-hidden bg-gray-50"
          style={{ 
            cursor: isDraggingBg ? 'grabbing' : 'default',
            backgroundImage: 'radial-gradient(circle, #d1d5db 1px, transparent 1px)',
            backgroundSize: '20px 20px'
          }}
          onMouseMove={handleBgMouseMove}
          onMouseUp={handleBgMouseUp}
          onMouseLeave={handleBgMouseUp}
        >
          {backgroundImage && (
            <img
              src={backgroundImage}
              alt="Store layout"
              style={{
                position: 'absolute',
                top: bgImagePosition.y,
                left: bgImagePosition.x,
                maxWidth: '100%',
                maxHeight: '100%',
                objectFit: 'contain',
                opacity: 0.3,
                pointerEvents: 'auto',
                cursor: isDraggingBg ? 'grabbing' : 'grab',
                zIndex: 0,
                userSelect: 'none'
              }}
              onMouseDown={handleBgMouseDown}
              draggable={false}
            />
          )}

          {fixtures.map(fixture => (
            <Fixture
              key={fixture.id}
              fixture={fixture}
              onUpdate={updateFixture}
              onDelete={deleteFixture}
              onSelect={() => setSelectedFixture(fixture.id)}
              isSelected={selectedFixture === fixture.id}
            />
          ))}
        </div>
      </div>

      {selectedFixture && (
        <div className="w-80 bg-white shadow-lg p-4 overflow-y-auto">
          <h2 className="text-xl font-bold mb-4">
            {fixtures.find(f => f.id === selectedFixture)?.name}
          </h2>

          <button
            onClick={() => addSection(selectedFixture)}
            className="w-full px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600 mb-4 flex items-center justify-center gap-2"
          >
            <Icons.Plus />
            Add Section
          </button>

          <div className="space-y-4">
            {sections
              .filter(s => s.fixtureId === selectedFixture)
              .map(section => {
                const metrics = calculateMetrics(section, timePeriod);
                
                return (
                  <div
                    key={section.id}
                    className={`p-4 border-2 rounded-lg ${selectedSection === section.id ? 'border-blue-500 bg-blue-50' : 'border-gray-200'}`}
                    onClick={() => setSelectedSection(section.id)}
                  >
                    <div className="flex items-center justify-between mb-2">
                      {editingSection === section.id ? (
                        <input
                          type="text"
                          value={editingSectionName}
                          onChange={(e) => setEditingSectionName(e.target.value)}
                          onBlur={() => {
                            if (editingSectionName.trim()) {
                              updateSectionName(section.id, editingSectionName.trim());
                            } else {
                              setEditingSection(null);
                            }
                          }}
                          onKeyPress={(e) => {
                            if (e.key === 'Enter' && editingSectionName.trim()) {
                              updateSectionName(section.id, editingSectionName.trim());
                            }
                            if (e.key === 'Escape') {
                              setEditingSection(null);
                            }
                          }}
                          className="flex-1 px-2 py-1 border-2 border-blue-500 rounded font-bold"
                          autoFocus
                          onClick={(e) => e.stopPropagation()}
                        />
                      ) : (
                        <h3 
                          className="font-bold cursor-pointer hover:text-blue-600 flex-1"
                          onClick={(e) => {
                            e.stopPropagation();
                            setEditingSection(section.id);
                            setEditingSectionName(section.name);
                          }}
                          title="Click to rename"
                        >
                          {section.name}
                        </h3>
                      )}
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          deleteSection(section.id);
                        }}
                        className="text-red-500 hover:text-red-700 ml-2"
                      >
                        <Icons.Trash2 />
                      </button>
                    </div>

                    <div className="text-sm space-y-1 mb-3">
                      <div className="flex items-center gap-2">
                        {editingSectionArea === section.id ? (
                          <input
                            type="number"
                            step="0.1"
                            min="0.1"
                            value={editingAreaValue}
                            onChange={(e) => setEditingAreaValue(e.target.value)}
                            onBlur={() => {
                              if (editingAreaValue.trim()) {
                                updateSectionArea(section.id, editingAreaValue);
                              } else {
                                setEditingSectionArea(null);
                              }
                            }}
                            onKeyPress={(e) => {
                              if (e.key === 'Enter' && editingAreaValue.trim()) {
                                updateSectionArea(section.id, editingAreaValue);
                              }
                              if (e.key === 'Escape') {
                                setEditingSectionArea(null);
                              }
                            }}
                            className="flex-1 px-2 py-1 border-2 border-blue-500 rounded text-sm"
                            autoFocus
                            onClick={(e) => e.stopPropagation()}
                          />
                        ) : (
                          <div
                            className="cursor-pointer hover:text-blue-600"
                            onClick={(e) => {
                              e.stopPropagation();
                              setEditingSectionArea(section.id);
                              setEditingAreaValue(section.area.toString());
                            }}
                            title="Click to edit area"
                          >
                            Area: {section.area} sq ft
                          </div>
                        )}
                      </div>
                      <div className="font-bold text-green-600">
                        Profit/sq ft: ${metrics.profitPerSqFt.toFixed(2)}
                      </div>
                      <div>Total Profit: ${metrics.totalProfit.toFixed(2)}</div>
                      <div>Products: {section.products.length}</div>
                    </div>

                    {/* Section Layout Controls */}
                    <div className="space-y-2 mb-3 border-t pt-3">
                      <div className="text-xs font-bold text-gray-600">SECTION LAYOUT</div>
                      <div className="grid grid-cols-2 gap-2">
                        <div>
                          <label className="text-xs text-gray-600">X Position %</label>
                          <input
                            type="number"
                            min="0"
                            max="100"
                            value={section.layoutX || 0}
                            onChange={(e) => {
                              const updatedSections = sections.map(s => 
                                s.id === section.id ? { ...s, layoutX: parseFloat(e.target.value) || 0 } : s
                              );
                              setSections(updatedSections);
                              autoSave(updatedSections, 'Section layout updated');
                            }}
                            className="w-full px-2 py-1 border rounded text-xs"
                            onClick={(e) => e.stopPropagation()}
                          />
                        </div>
                        <div>
                          <label className="text-xs text-gray-600">Y Position %</label>
                          <input
                            type="number"
                            min="0"
                            max="100"
                            value={section.layoutY || 0}
                            onChange={(e) => {
                              const updatedSections = sections.map(s => 
                                s.id === section.id ? { ...s, layoutY: parseFloat(e.target.value) || 0 } : s
                              );
                              setSections(updatedSections);
                              autoSave(updatedSections, 'Section layout updated');
                            }}
                            className="w-full px-2 py-1 border rounded text-xs"
                            onClick={(e) => e.stopPropagation()}
                          />
                        </div>
                        <div>
                          <label className="text-xs text-gray-600">Width %</label>
                          <input
                            type="number"
                            min="1"
                            max="100"
                            value={section.layoutWidth || 100}
                            onChange={(e) => {
                              const updatedSections = sections.map(s => 
                                s.id === section.id ? { ...s, layoutWidth: parseFloat(e.target.value) || 100 } : s
                              );
                              setSections(updatedSections);
                              autoSave(updatedSections, 'Section layout updated');
                            }}
                            className="w-full px-2 py-1 border rounded text-xs"
                            onClick={(e) => e.stopPropagation()}
                          />
                        </div>
                        <div>
                          <label className="text-xs text-gray-600">Height %</label>
                          <input
                            type="number"
                            min="1"
                            max="100"
                            value={section.layoutHeight || 100}
                            onChange={(e) => {
                              const updatedSections = sections.map(s => 
                                s.id === section.id ? { ...s, layoutHeight: parseFloat(e.target.value) || 100 } : s
                              );
                              setSections(updatedSections);
                              autoSave(updatedSections, 'Section layout updated');
                            }}
                            className="w-full px-2 py-1 border rounded text-xs"
                            onClick={(e) => e.stopPropagation()}
                          />
                        </div>
                      </div>
                      <div className="flex gap-2">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            const updatedSections = sections.map(s => 
                              s.id === section.id ? { ...s, layoutX: 0, layoutY: 0, layoutWidth: 100, layoutHeight: 100 } : s
                            );
                            setSections(updatedSections);
                            autoSave(updatedSections, 'Section layout reset');
                          }}
                          className="flex-1 px-2 py-1 bg-gray-200 text-xs rounded hover:bg-gray-300"
                        >
                          Reset Layout
                        </button>
                      </div>
                      <div className="text-xs text-gray-600 mt-2">Quick Layouts:</div>
                      <div className="grid grid-cols-3 gap-1">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            const updatedSections = sections.map(s => 
                              s.id === section.id ? { ...s, layoutX: 0, layoutY: 0, layoutWidth: 50, layoutHeight: 100 } : s
                            );
                            setSections(updatedSections);
                            autoSave(updatedSections);
                          }}
                          className="px-2 py-1 bg-blue-100 text-xs rounded hover:bg-blue-200"
                          title="Left Half"
                        >
                          â¬…ï¸ Left
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            const updatedSections = sections.map(s => 
                              s.id === section.id ? { ...s, layoutX: 50, layoutY: 0, layoutWidth: 50, layoutHeight: 100 } : s
                            );
                            setSections(updatedSections);
                            autoSave(updatedSections);
                          }}
                          className="px-2 py-1 bg-blue-100 text-xs rounded hover:bg-blue-200"
                          title="Right Half"
                        >
                          Right âž¡ï¸
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            const updatedSections = sections.map(s => 
                              s.id === section.id ? { ...s, layoutX: 0, layoutY: 0, layoutWidth: 100, layoutHeight: 50 } : s
                            );
                            setSections(updatedSections);
                            autoSave(updatedSections);
                          }}
                          className="px-2 py-1 bg-blue-100 text-xs rounded hover:bg-blue-200"
                          title="Top Half"
                        >
                          â¬†ï¸ Top
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            const updatedSections = sections.map(s => 
                              s.id === section.id ? { ...s, layoutX: 0, layoutY: 50, layoutWidth: 100, layoutHeight: 50 } : s
                            );
                            setSections(updatedSections);
                            autoSave(updatedSections);
                          }}
                          className="px-2 py-1 bg-blue-100 text-xs rounded hover:bg-blue-200"
                          title="Bottom Half"
                        >
                          Bottom â¬‡ï¸
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            const updatedSections = sections.map(s => 
                              s.id === section.id ? { ...s, layoutX: 0, layoutY: 0, layoutWidth: 33, layoutHeight: 100 } : s
                            );
                            setSections(updatedSections);
                            autoSave(updatedSections);
                          }}
                          className="px-2 py-1 bg-green-100 text-xs rounded hover:bg-green-200"
                          title="1/3 Width"
                        >
                          1/3
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            const updatedSections = sections.map(s => 
                              s.id === section.id ? { ...s, layoutX: 0, layoutY: 0, layoutWidth: 25, layoutHeight: 100 } : s
                            );
                            setSections(updatedSections);
                            autoSave(updatedSections);
                          }}
                          className="px-2 py-1 bg-green-100 text-xs rounded hover:bg-green-200"
                          title="1/4 Width"
                        >
                          1/4
                        </button>
                      </div>
                    </div>

                    {/* Rows Section */}
                    <div className="border-t pt-3 mb-3">
                      <div className="flex justify-between items-center mb-2">
                        <h4 className="font-semibold text-sm">Rows (Height Tracking)</h4>
                        <button
                          onClick={() => addRowToSection(section.id)}
                          className="px-2 py-1 bg-green-500 text-white rounded text-xs hover:bg-green-600"
                        >
                          + Add Row
                        </button>
                      </div>
                      
                      <div className="space-y-2">
                        {(section.rows || []).map((row, rowIdx) => {
                          const rowProfit = row.products.reduce((sum, p) => 
                            sum + ((parseFloat(p.price) - parseFloat(p.cost)) * p.quantity), 0
                          );
                          const isSelectedRow = selectedRow === row.id;
                          
                          return (
                            <div 
                              key={row.id}
                              className={`p-2 rounded border-2 cursor-pointer transition ${
                                isSelectedRow ? 'border-blue-500 bg-blue-50' : 'border-gray-200 bg-white hover:border-blue-300'
                              }`}
                              onClick={() => {
                                setSelectedRow(row.id);
                                setNewProduct({ ...newProduct, sectionId: section.id, rowId: row.id });
                              }}
                            >
                              <div className="flex justify-between items-center mb-1">
                                <div className="font-medium text-sm">{row.name}</div>
                                <button
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    deleteRow(section.id, row.id);
                                  }}
                                  className="text-red-500 hover:text-red-700 text-xs"
                                >
                                  <Icons.Trash2 />
                                </button>
                              </div>
                              <div className="text-xs text-gray-600">
                                {row.products.length} products | ${rowProfit.toFixed(2)} profit
                              </div>
                              
                              {isSelectedRow && row.products.length > 0 && (
                                <div className="mt-2 space-y-1">
                                  {row.products.map((product, pIdx) => (
                                    <div key={pIdx} className="flex items-center justify-between text-xs bg-gray-50 p-1 rounded">
                                      <span className="truncate flex-1">{product.name}</span>
                                      <span className="text-gray-600">Qty: {product.quantity}</span>
                                    </div>
                                  ))}
                                </div>
                              )}
                            </div>
                          );
                        })}
                      </div>
                    </div>

                    <div className="space-y-2 mb-3 border-t pt-3">
                      <input
                        type="text"
                        placeholder="Scan or enter UPC (select a row first)"
                        value={selectedSection === section.id ? newProduct.upc : ''}
                        onChange={(e) => {
                          setSelectedSection(section.id);
                          setNewProduct({ ...newProduct, upc: e.target.value, sectionId: section.id });
                        }}
                        className="w-full px-3 py-2 border rounded text-sm"
                        onKeyPress={(e) => {
                          if (e.key === 'Enter' && newProduct.upc && newProduct.rowId) {
                            addProductToSection();
                          }
                        }}
                      />
                      <button
                        onClick={() => {
                          if (!newProduct.rowId) {
                            setFeedback('âš ï¸ Select a row first');
                            setTimeout(() => setFeedback(''), 2000);
                            return;
                          }
                          addProductToSection();
                        }}
                        disabled={scanning || !newProduct.upc || !newProduct.rowId}
                        className="w-full px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300 text-sm"
                      >
                        {scanning ? 'Adding...' : newProduct.rowId ? 'Add Product to Row' : 'Select Row First'}
                      </button>
                    </div>

                    <div className="space-y-2">
                      {section.products.map((product, idx) => (
                        <div key={idx} className="flex items-center justify-between p-2 bg-gray-50 rounded text-sm">
                          <div className="flex-1">
                            <div className="font-medium">{product.name}</div>
                            <div className="text-xs text-gray-600">
                              ${product.price} | Qty: {product.quantity}
                            </div>
                          </div>
                          
                          <div className="flex gap-1">
                            <button
                              onClick={() => updateProductQuantity(section.id, idx, -1)}
                              className="px-2 py-1 text-xs bg-gray-200 rounded hover:bg-gray-300"
                            >
                              -
                            </button>
                            <button
                              onClick={() => updateProductQuantity(section.id, idx, 1)}
                              className="px-2 py-1 text-xs bg-gray-200 rounded hover:bg-gray-300"
                            >
                              +
                            </button>
                            
                            <button
                              onClick={() => deleteProduct(section.id, idx)}
                              className="px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600"
                              title="Delete"
                            >
                              ðŸ—‘ï¸
                            </button>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                );
              })}
          </div>
        </div>
      )}

      {showSettings && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 max-w-md w-full">
            <h2 className="text-2xl font-bold mb-4">ðŸ›ï¸ Shopify Connection</h2>

            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium mb-1">Store Name</label>
                <input
                  type="text"
                  value={shopifyConfig.storeName}
                  onChange={(e) => setShopifyConfig({ ...shopifyConfig, storeName: e.target.value })}
                  placeholder="your-store.myshopify.com"
                  className="w-full px-3 py-2 border rounded"
                  disabled={shopifyConfig.connected}
                />
              </div>

              <div>
                <label className="block text-sm font-medium mb-1">Admin API Access Token</label>
                <input
                  type="password"
                  value={shopifyConfig.accessToken}
                  onChange={(e) => setShopifyConfig({ ...shopifyConfig, accessToken: e.target.value })}
                  placeholder="shpat_xxxxx..."
                  className="w-full px-3 py-2 border rounded"
                  disabled={shopifyConfig.connected}
                />
              </div>

              <div className="flex gap-2">
                {!shopifyConfig.connected ? (
                  <button
                    onClick={testShopifyConnection}
                    className="flex-1 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
                  >
                    Test Connection
                  </button>
                ) : (
                  <>
                    <button
                      onClick={refreshProductCache}
                      className="flex-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 flex items-center justify-center gap-2"
                    >
                      <Icons.RefreshCw />
                      Refresh
                    </button>
                    <button
                      onClick={disconnectShopify}
                      className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                    >
                      Disconnect
                    </button>
                  </>
                )}
              </div>

              {shopifyConfig.connected && (
                <div className="p-3 bg-green-100 text-green-800 rounded">
                  âœ… Connected
                </div>
              )}
            </div>

            <button
              onClick={() => setShowSettings(false)}
              className="mt-4 w-full px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
            >
              Close
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

    createRoot(document.getElementById('root')).render(<PlanogramProfitTracker />);
  </script>
</body>
</html>
